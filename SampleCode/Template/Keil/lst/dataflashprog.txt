; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\dataflashprog.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\dataflashprog.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\dataflashprog.crf ..\DataFlashProg.c]
                          THUMB

                          AREA ||i.DataFlashInit||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  DataFlashInit PROC
;;;37     
;;;38     void DataFlashInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;39     {
;;;40         uint32_t au32Config[2];
;;;41     	uint32_t u32Data = 0;
;;;42     
;;;43         CLK->AHBCLK |= CLK_AHBCLK_ISPCKEN_Msk;
000002  f04f4480          MOV      r4,#0x40000000
000006  f8d40204          LDR      r0,[r4,#0x204]
00000a  f0400004          ORR      r0,r0,#4
00000e  f8c40204          STR      r0,[r4,#0x204]
;;;44     
;;;45         SYS_UnlockReg();
000012  f7fffffe          BL       SYS_UnlockReg
;;;46         FMC_Open();
000016  f7fffffe          BL       FMC_Open
;;;47     
;;;48     	#if 1
;;;49         /* Check if Data Flash Size is 64K. If not, to re-define Data Flash size and to enable Data Flash function */
;;;50         if (FMC_ReadConfig(au32Config, 2) < 0)
00001a  2102              MOVS     r1,#2
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       FMC_ReadConfig
000022  2800              CMP      r0,#0
000024  da03              BGE      |L1.46|
;;;51         {
;;;52     		printf("%s : 1\r\n" , __FUNCTION__ );
000026  4925              LDR      r1,|L1.188|
000028  a025              ADR      r0,|L1.192|
00002a  f7fffffe          BL       __2printf
                  |L1.46|
;;;53         }
;;;54     
;;;55         if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != DATA_FLASH_BASE) )
00002e  9800              LDR      r0,[sp,#0]
000030  f44f26fc          MOV      r6,#0x7e000
000034  07c0              LSLS     r0,r0,#31
000036  f04f0500          MOV      r5,#0
00003a  d102              BNE      |L1.66|
00003c  9801              LDR      r0,[sp,#4]
00003e  42b0              CMP      r0,r6
000040  d031              BEQ      |L1.166|
                  |L1.66|
;;;56         {
;;;57             FMC_ENABLE_CFG_UPDATE();
000042  4822              LDR      r0,|L1.204|
000044  6801              LDR      r1,[r0,#0]
000046  f0410110          ORR      r1,r1,#0x10
00004a  6001              STR      r1,[r0,#0]
;;;58             au32Config[0] &= ~0x1;
00004c  9800              LDR      r0,[sp,#0]
;;;59             au32Config[1] = DATA_FLASH_BASE;
;;;60             if (FMC_WriteConfig(au32Config, 2) < 0)
00004e  2102              MOVS     r1,#2
000050  f0200001          BIC      r0,r0,#1              ;58
000054  e9cd0600          STRD     r0,r6,[sp,#0]
000058  4668              MOV      r0,sp
00005a  f7fffffe          BL       FMC_WriteConfig
00005e  2800              CMP      r0,#0
000060  da03              BGE      |L1.106|
;;;61     	    {
;;;62     			printf("%s : 2\r\n" , __FUNCTION__ );
000062  4916              LDR      r1,|L1.188|
000064  a01a              ADR      r0,|L1.208|
000066  f7fffffe          BL       __2printf
                  |L1.106|
;;;63     	    }
;;;64     
;;;65             FMC_ReadConfig(au32Config, 2);
00006a  2102              MOVS     r1,#2
00006c  4668              MOV      r0,sp
00006e  f7fffffe          BL       FMC_ReadConfig
;;;66             if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != DATA_FLASH_BASE))
000072  9800              LDR      r0,[sp,#0]
000074  07c0              LSLS     r0,r0,#31
000076  d102              BNE      |L1.126|
000078  9801              LDR      r0,[sp,#4]
00007a  42b0              CMP      r0,r6
00007c  d00a              BEQ      |L1.148|
                  |L1.126|
;;;67             {
;;;68                 printf("Error: Program Config Failed!\n");
00007e  a017              ADR      r0,|L1.220|
000080  f7fffffe          BL       __2printf
;;;69                 /* Disable FMC ISP function */
;;;70                 FMC_Close();
000084  f7fffffe          BL       FMC_Close
000088  f8c45100          STR      r5,[r4,#0x100]
;;;71                 SYS_LockReg();
;;;72     		    {
;;;73     				printf("%s : 3\r\n" , __FUNCTION__ );
00008c  490b              LDR      r1,|L1.188|
00008e  a01b              ADR      r0,|L1.252|
000090  f7fffffe          BL       __2printf
                  |L1.148|
;;;74     		    }
;;;75     
;;;76             }
;;;77     
;;;78             printf("chip reset\n");
000094  a01c              ADR      r0,|L1.264|
000096  f7fffffe          BL       __2printf
                  |L1.154|
;;;79     
;;;80             /* To check if all the debug messages are finished */
;;;81             while(!IsDebugFifoEmpty());
00009a  f7fffffe          BL       IsDebugFifoEmpty
00009e  2800              CMP      r0,#0
0000a0  d0fb              BEQ      |L1.154|
;;;82     		
;;;83             /* Reset Chip to reload new CONFIG value */
;;;84             SYS->IPRST0 = SYS_IPRST0_CHIPRST_Msk;
0000a2  2001              MOVS     r0,#1
0000a4  60a0              STR      r0,[r4,#8]
                  |L1.166|
;;;85         }
;;;86     	#endif
;;;87     
;;;88         u32Data = FMC_ReadDataFlashBaseAddr();
0000a6  f7fffffe          BL       FMC_ReadDataFlashBaseAddr
0000aa  4601              MOV      r1,r0
;;;89         printf("Data Flash Base Address [0x%08X]\r\n", u32Data);
0000ac  a019              ADR      r0,|L1.276|
0000ae  f7fffffe          BL       __2printf
;;;90     	
;;;91         FMC_Close();
0000b2  f7fffffe          BL       FMC_Close
0000b6  f8c45100          STR      r5,[r4,#0x100]
;;;92         SYS_LockReg();
;;;93     }
0000ba  bd7c              POP      {r2-r6,pc}
;;;94     
                          ENDP

                  |L1.188|
                          DCD      ||.constdata||
                  |L1.192|
0000c0  2573203a          DCB      "%s : 1\r\n",0
0000c4  20310d0a
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L1.204|
                          DCD      0x4000c000
                  |L1.208|
0000d0  2573203a          DCB      "%s : 2\r\n",0
0000d4  20320d0a
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L1.220|
0000dc  4572726f          DCB      "Error: Program Config Failed!\n",0
0000e0  723a2050
0000e4  726f6772
0000e8  616d2043
0000ec  6f6e6669
0000f0  67204661
0000f4  696c6564
0000f8  210a00  
0000fb  00                DCB      0
                  |L1.252|
0000fc  2573203a          DCB      "%s : 3\r\n",0
000100  20330d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L1.264|
000108  63686970          DCB      "chip reset\n",0
00010c  20726573
000110  65740a00
                  |L1.276|
000114  44617461          DCB      "Data Flash Base Address [0x%08X]\r\n",0
000118  20466c61
00011c  73682042
000120  61736520
000124  41646472
000128  65737320
00012c  5b307825
000130  3038585d
000134  0d0a00  
000137  00                DCB      0

                          AREA ||i.DataFlashProgramPage||, CODE, READONLY, ALIGN=1

                  DataFlashProgramPage PROC
;;;139    
;;;140    uint32_t DataFlashProgramPage(uint32_t u32StartAddr, uint32_t * u32Buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;141    {
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;142        uint32_t i;
;;;143    	
;;;144        for(i = 0; i < FLASH_PAGE_SIZE / 4; i++)
000008  2400              MOVS     r4,#0
00000a  f44f6780          MOV      r7,#0x400
                  |L2.14|
;;;145        {
;;;146            FMC_Write(u32StartAddr + i * 4, u32Buf[i]);
00000e  f8551024          LDR      r1,[r5,r4,LSL #2]
000012  eb060084          ADD      r0,r6,r4,LSL #2
000016  f7fffffe          BL       FMC_Write
00001a  1c64              ADDS     r4,r4,#1
00001c  42bc              CMP      r4,r7                 ;144
00001e  d3f6              BCC      |L2.14|
;;;147    //		printf("program page : 0x%4X , 0x%4X \r\n" , u32StartAddr , u32Buf[i]);
;;;148        }
;;;149    
;;;150        return 0;
000020  2000              MOVS     r0,#0
;;;151    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;152    
                          ENDP


                          AREA ||i.DataFlashRead||, CODE, READONLY, ALIGN=2

                  DataFlashRead PROC
;;;106    
;;;107    void DataFlashRead(uint32_t addr, uint32_t size, uint32_t buffer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;108    {
000004  4617              MOV      r7,r2
000006  460e              MOV      r6,r1
;;;109        /* This is low level read function of USB Mass Storage */
;;;110        int32_t len;
;;;111        uint32_t i;
;;;112        uint32_t * pu32Buf = (uint32_t *)buffer;
000008  4690              MOV      r8,r2
00000a  f50025fc          ADD      r5,r0,#0x7e000
;;;113    	
;;;114        /* Modify the address to DATA_FLASH_BASE */
;;;115        addr += DATA_FLASH_BASE;
;;;116    
;;;117        len = (int32_t)size;
;;;118    
;;;119        SYS_UnlockReg();
00000e  f7fffffe          BL       SYS_UnlockReg
;;;120        FMC_Open();
000012  f7fffffe          BL       FMC_Open
;;;121        FMC_ENABLE_AP_UPDATE();
000016  f8df9050          LDR      r9,|L3.104|
00001a  f8d91000          LDR      r1,[r9,#0]
00001e  f0410108          ORR      r1,r1,#8
000022  f8c91000          STR      r1,[r9,#0]
;;;122    
;;;123        while(len >= BUFFER_PAGE_SIZE)
000026  e00d              B        |L3.68|
                  |L3.40|
;;;124        {
;;;125            //FMC_ReadPage(addr, (uint32_t *)buffer);
;;;126            for(i = 0; i < BUFFER_PAGE_SIZE / 4; i++)
000028  2400              MOVS     r4,#0
                  |L3.42|
;;;127                pu32Buf[i] = FMC_Read(addr + i * 4);
00002a  eb050084          ADD      r0,r5,r4,LSL #2
00002e  f7fffffe          BL       FMC_Read
000032  f8480024          STR      r0,[r8,r4,LSL #2]
000036  1c64              ADDS     r4,r4,#1
000038  2c02              CMP      r4,#2                 ;126
00003a  d3f6              BCC      |L3.42|
00003c  3708              ADDS     r7,r7,#8              ;126
;;;128            addr   += BUFFER_PAGE_SIZE;
;;;129            buffer += BUFFER_PAGE_SIZE;
;;;130            len  -= BUFFER_PAGE_SIZE;
;;;131            pu32Buf = (uint32_t *)buffer;
00003e  3508              ADDS     r5,r5,#8
000040  46b8              MOV      r8,r7
000042  3e08              SUBS     r6,r6,#8
                  |L3.68|
000044  2e08              CMP      r6,#8                 ;123
000046  daef              BGE      |L3.40|
;;;132        }
;;;133    
;;;134    	FMC_DISABLE_AP_UPDATE();
000048  f8d91000          LDR      r1,[r9,#0]
00004c  f0210108          BIC      r1,r1,#8
000050  f8c91000          STR      r1,[r9,#0]
;;;135        FMC_Close();
000054  f7fffffe          BL       FMC_Close
000058  f04f4180          MOV      r1,#0x40000000
00005c  2000              MOVS     r0,#0
00005e  f8c10100          STR      r0,[r1,#0x100]
;;;136        SYS_LockReg();
;;;137    }
000062  e8bd87f0          POP      {r4-r10,pc}
;;;138    
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      0x4000c000

                          AREA ||i.DataFlashReadPage||, CODE, READONLY, ALIGN=1

                  DataFlashReadPage PROC
;;;94     
;;;95     void DataFlashReadPage(uint32_t addr, uint32_t buffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;96     {
000004  460e              MOV      r6,r1
000006  f50025fc          ADD      r5,r0,#0x7e000
;;;97         uint32_t i;
;;;98         uint32_t * pu32Buf = (uint32_t *)buffer;
;;;99     
;;;100        /* Modify the address to MASS_STORAGE_OFFSET */
;;;101        addr += DATA_FLASH_BASE;
;;;102    
;;;103        for(i = 0; i < FLASH_PAGE_SIZE / 4; i++)
00000a  2400              MOVS     r4,#0
00000c  f44f6780          MOV      r7,#0x400
                  |L4.16|
;;;104            pu32Buf[i] = FMC_Read(addr + i * 4);
000010  eb050084          ADD      r0,r5,r4,LSL #2
000014  f7fffffe          BL       FMC_Read
000018  f8460024          STR      r0,[r6,r4,LSL #2]
00001c  1c64              ADDS     r4,r4,#1
00001e  42bc              CMP      r4,r7                 ;103
000020  d3f6              BCC      |L4.16|
;;;105    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;106    
                          ENDP


                          AREA ||i.DataFlashWrite||, CODE, READONLY, ALIGN=2

                  DataFlashWrite PROC
;;;153    
;;;154    void DataFlashWrite(uint32_t addr, uint32_t size, uint32_t buffer)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;155    {
000004  4617              MOV      r7,r2
000006  460e              MOV      r6,r1
000008  4605              MOV      r5,r0
;;;156        /* This is low level write function of USB Mass Storage */
;;;157        int32_t len, i, offset;
;;;158        uint32_t *pu32;
;;;159        uint32_t alignAddr;
;;;160    
;;;161        SYS_UnlockReg();
00000a  f7fffffe          BL       SYS_UnlockReg
;;;162        FMC_Open();
00000e  f7fffffe          BL       FMC_Open
;;;163        FMC_ENABLE_AP_UPDATE();
000012  f8dfb0c4          LDR      r11,|L5.216|
000016  f8db0000          LDR      r0,[r11,#0]
00001a  f0400008          ORR      r0,r0,#8
00001e  f8cb0000          STR      r0,[r11,#0]
;;;164    	
;;;165        /* Modify the address to DATA_FLASH_BASE */
;;;166        addr += DATA_FLASH_BASE;
;;;167    
;;;168        len = (int32_t)size;
;;;169    
;;;170        if((len == FLASH_PAGE_SIZE) && ((addr & (FLASH_PAGE_SIZE - 1)) == 0))
000022  f44f5a80          MOV      r10,#0x1000
000026  f50525fc          ADD      r5,r5,#0x7e000
00002a  4556              CMP      r6,r10
00002c  d112              BNE      |L5.84|
00002e  0528              LSLS     r0,r5,#20
000030  d110              BNE      |L5.84|
;;;171        {
;;;172            /* Page erase */
;;;173            FMC_Erase(addr);
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       FMC_Erase
000038  4654              MOV      r4,r10                ;170
                  |L5.58|
;;;174    
;;;175            while(len >= FLASH_PAGE_SIZE)
;;;176            {
;;;177                DataFlashProgramPage(addr, (uint32_t *) buffer);
00003a  4639              MOV      r1,r7
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       DataFlashProgramPage
000042  f5a65680          SUB      r6,r6,#0x1000
000046  f5055580          ADD      r5,r5,#0x1000
00004a  f5075780          ADD      r7,r7,#0x1000
00004e  42a6              CMP      r6,r4                 ;175
;;;178                len    -= FLASH_PAGE_SIZE;
;;;179                buffer += FLASH_PAGE_SIZE;
;;;180                addr   += FLASH_PAGE_SIZE;
000050  d2f3              BCS      |L5.58|
000052  e032              B        |L5.186|
                  |L5.84|
;;;181            }
;;;182        }
;;;183        else
;;;184        {
;;;185            do
;;;186            {
;;;187                alignAddr = addr & 0xFFF000;
000054  4921              LDR      r1,|L5.220|
;;;188    //			printf("alignAddr : 0x%4X\r\n" , alignAddr);
;;;189    
;;;190                /* Get the sector offset*/
;;;191                offset = (addr & (FLASH_PAGE_SIZE - 1));
000056  f3c5000b          UBFX     r0,r5,#0,#12
00005a  ea050901          AND      r9,r5,r1              ;187
00005e  ea5f0800          MOVS     r8,r0
;;;192    //			printf("offset : 0x%4X\r\n" , offset);
;;;193    
;;;194                if(offset || (size < FLASH_PAGE_SIZE))
000062  d101              BNE      |L5.104|
000064  4556              CMP      r6,r10
000066  d204              BCS      |L5.114|
                  |L5.104|
;;;195                {
;;;196                    /* Not 4096-byte alignment. Read the destination page for modification. Note: It needs to avoid adding MASS_STORAGE_OFFSET twice. */
;;;197                    DataFlashReadPage(alignAddr - DATA_FLASH_BASE, /*FLASH_PAGE_SIZE,*/ (uint32_t)&g_sectorBuf[0]);
000068  491d              LDR      r1,|L5.224|
00006a  f5a920fc          SUB      r0,r9,#0x7e000
00006e  f7fffffe          BL       DataFlashReadPage
                  |L5.114|
;;;198    
;;;199                }
;;;200    
;;;201                /* Source buffer */
;;;202                pu32 = (uint32_t *)buffer;
;;;203    //			printf("pu32 : 0x%4X , 0x%4X , 0x%4X\r\n" , pu32[0] , buffer , &buffer);			
;;;204                /* Get the update length */
;;;205                len = FLASH_PAGE_SIZE - offset;
000072  f5c85480          RSB      r4,r8,#0x1000
;;;206                if(size < len)
000076  42a6              CMP      r6,r4
000078  d200              BCS      |L5.124|
;;;207                    len = size;
00007a  4634              MOV      r4,r6
                  |L5.124|
;;;208                /* Update the destination buffer */
;;;209                for(i = 0; i < len / 4; i++)
;;;210                {
;;;211                    g_sectorBuf[offset / 4 + i] = pu32[i];
00007c  ea4f72e8          ASR      r2,r8,#31
000080  2000              MOVS     r0,#0                 ;209
000082  eb087892          ADD      r8,r8,r2,LSR #30
000086  17e2              ASRS     r2,r4,#31             ;209
000088  4915              LDR      r1,|L5.224|
00008a  eb047c92          ADD      r12,r4,r2,LSR #30     ;209
00008e  e006              B        |L5.158|
                  |L5.144|
000090  f8572020          LDR      r2,[r7,r0,LSL #2]
000094  eb0003a8          ADD      r3,r0,r8,ASR #2
000098  1c40              ADDS     r0,r0,#1
00009a  f8412023          STR      r2,[r1,r3,LSL #2]
                  |L5.158|
00009e  ebb00fac          CMP      r0,r12,ASR #2         ;209
0000a2  dbf5              BLT      |L5.144|
;;;212                }
;;;213    //			printf("g_sectorBuf : 0x%4X\r\n" , g_sectorBuf[0]);
;;;214    
;;;215                /* Page erase */
;;;216                FMC_Erase(alignAddr);
0000a4  4648              MOV      r0,r9
0000a6  f7fffffe          BL       FMC_Erase
;;;217                /* Write to the destination page */
;;;218                DataFlashProgramPage(alignAddr, (uint32_t *) g_sectorBuf);
0000aa  490d              LDR      r1,|L5.224|
0000ac  4648              MOV      r0,r9
0000ae  f7fffffe          BL       DataFlashProgramPage
;;;219    
;;;220                size -= len;
0000b2  1b36              SUBS     r6,r6,r4
;;;221                addr += len;
0000b4  4425              ADD      r5,r5,r4
;;;222                buffer += len;
0000b6  4427              ADD      r7,r7,r4
;;;223    
;;;224            }
;;;225            while(size > 0);
0000b8  d1cc              BNE      |L5.84|
                  |L5.186|
;;;226        }
;;;227    
;;;228        FMC_DISABLE_AP_UPDATE(); 	
0000ba  f8db1000          LDR      r1,[r11,#0]
0000be  f0210108          BIC      r1,r1,#8
0000c2  f8cb1000          STR      r1,[r11,#0]
;;;229        FMC_Close();
0000c6  f7fffffe          BL       FMC_Close
0000ca  f04f4180          MOV      r1,#0x40000000
0000ce  2000              MOVS     r0,#0
0000d0  f8c10100          STR      r0,[r1,#0x100]
;;;230        SYS_LockReg();
;;;231    	
;;;232    }
0000d4  e8bd9ff0          POP      {r4-r12,pc}
;;;233    
                          ENDP

                  |L5.216|
                          DCD      0x4000c000
                  |L5.220|
                          DCD      0x00fff000
                  |L5.224|
                          DCD      ||.bss||

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=1

                  SYS_UnlockReg PROC
;;;1585     */
;;;1586   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1587   {
000002  b510              PUSH     {r4,lr}
;;;1588       do
;;;1589       {
;;;1590           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1591           SYS->REGLCTL = 0x16UL;
000006  2216              MOVS     r2,#0x16
;;;1592           SYS->REGLCTL = 0x88UL;
000008  2388              MOVS     r3,#0x88
                  |L6.10|
00000a  f8c01100          STR      r1,[r0,#0x100]        ;1590
00000e  f8c02100          STR      r2,[r0,#0x100]        ;1591
000012  f8c03100          STR      r3,[r0,#0x100]
;;;1593       }
;;;1594       while(SYS->REGLCTL == 0UL);
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L6.10|
;;;1595   }
00001e  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_sectorBuf
                          %        4096

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  44617461          DCB      0x44,0x61,0x74,0x61
000004  466c6173          DCB      0x46,0x6c,0x61,0x73
000008  68496e69          DCB      0x68,0x49,0x6e,0x69
00000c  7400              DCB      0x74,0x00

;*** Start embedded assembler ***

#line 1 "..\\DataFlashProg.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_DataFlashProg_c_d5928c7a____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_DataFlashProg_c_d5928c7a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_DataFlashProg_c_d5928c7a____REVSH|
#line 402
|__asm___15_DataFlashProg_c_d5928c7a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_DataFlashProg_c_d5928c7a____RRX|
#line 587
|__asm___15_DataFlashProg_c_d5928c7a____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
