; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Custom_Init||, CODE, READONLY, ALIGN=2

                  Custom_Init PROC
;;;284    
;;;285    void Custom_Init(void)
000000  b510              PUSH     {r4,lr}
;;;286    {
;;;287    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH0MFP_Msk)) | (SYS_GPH_MFPL_PH0MFP_GPIO);
000002  f04f4080          MOV      r0,#0x40000000
000006  6e81              LDR      r1,[r0,#0x68]
000008  f021010f          BIC      r1,r1,#0xf
00000c  6681              STR      r1,[r0,#0x68]
;;;288    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH1MFP_Msk)) | (SYS_GPH_MFPL_PH1MFP_GPIO);
00000e  6e81              LDR      r1,[r0,#0x68]
000010  f02101f0          BIC      r1,r1,#0xf0
000014  6681              STR      r1,[r0,#0x68]
;;;289    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH2MFP_Msk)) | (SYS_GPH_MFPL_PH2MFP_GPIO);
000016  6e81              LDR      r1,[r0,#0x68]
000018  f4216170          BIC      r1,r1,#0xf00
00001c  6681              STR      r1,[r0,#0x68]
;;;290    
;;;291    	//EVM LED
;;;292    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
00001e  4c09              LDR      r4,|L1.68|
000020  2201              MOVS     r2,#1
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_SetMode
;;;293    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00002a  2201              MOVS     r2,#1
00002c  2102              MOVS     r1,#2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_SetMode
;;;294    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000034  4620              MOV      r0,r4
000036  2201              MOVS     r2,#1
000038  e8bd4010          POP      {r4,lr}
00003c  2104              MOVS     r1,#4
00003e  f7ffbffe          B.W      GPIO_SetMode
;;;295    	
;;;296    }
;;;297    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  NVIC_SystemReset PROC
;;;1789    */
;;;1790   __STATIC_INLINE void NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
;;;1791   {
;;;1792     __DSB();                                                          /* Ensure all outstanding memory accesses included
;;;1793                                                                          buffered write are completed before reset */
;;;1794     SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
000004  4805              LDR      r0,|L3.28|
000006  6801              LDR      r1,[r0,#0]
000008  4a05              LDR      r2,|L3.32|
00000a  f40161e0          AND      r1,r1,#0x700
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
;;;1795                              (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
;;;1796                               SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
;;;1797     __DSB();                                                          /* Ensure completion of memory access */
000012  f3bf8f4f          DSB      
                  |L3.22|
;;;1798   
;;;1799     for(;;)                                                           /* wait until reset */
;;;1800     {
;;;1801       __NOP();
000016  bf00              NOP      
000018  e7fd              B        |L3.22|
;;;1802     }
;;;1803   }
;;;1804   
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0xe000ed0c
                  |L3.32|
                          DCD      0x05fa0004

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;297    
;;;298    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L4.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L4.10|
;;;299    {
;;;300        /* Unlock protected registers */
;;;301        SYS_UnlockReg();
;;;302    
;;;303        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;304        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2040          MOV      r0,#0x40004000
000022  f8d01140          LDR      r1,[r0,#0x140]
000026  f02101f0          BIC      r1,r1,#0xf0
00002a  f8c01140          STR      r1,[r0,#0x140]
;;;305    
;;;306        /* Enable External XTAL (4~24 MHz) */
;;;307        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk|CLK_PWRCTL_HIRCEN_Msk);
00002e  2005              MOVS     r0,#5
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;308    
;;;309        /* Waiting for 12MHz clock ready */
;;;310        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk|CLK_STATUS_HIRCSTB_Msk);
000034  2011              MOVS     r0,#0x11
000036  f7fffffe          BL       CLK_WaitClockReady
;;;311    
;;;312        CLK_EnableXtalRC(CLK_PWRCTL_LXTEN_Msk|CLK_PWRCTL_LIRCEN_Msk);
00003a  200a              MOVS     r0,#0xa
00003c  f7fffffe          BL       CLK_EnableXtalRC
;;;313    
;;;314        /* Waiting for 12MHz clock ready */
;;;315        CLK_WaitClockReady(CLK_STATUS_LXTSTB_Msk|CLK_STATUS_LIRCSTB_Msk);
000040  200a              MOVS     r0,#0xa
000042  f7fffffe          BL       CLK_WaitClockReady
;;;316    
;;;317        /* Set core clock as PLL_CLOCK from PLL */
;;;318        CLK_SetCoreClock(FREQ_192MHZ);
000046  4814              LDR      r0,|L4.152|
000048  f7fffffe          BL       CLK_SetCoreClock
;;;319        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;320        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
00004c  2011              MOVS     r0,#0x11
00004e  f8c40234          STR      r0,[r4,#0x234]
;;;321    
;;;322        /* Enable UART clock */
;;;323        CLK_EnableModuleClock(UART0_MODULE);
000052  4d12              LDR      r5,|L4.156|
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       CLK_EnableModuleClock
;;;324        /* Select UART clock source from HXT */
;;;325        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
00005a  2200              MOVS     r2,#0
00005c  f04f7140          MOV      r1,#0x3000000
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       CLK_SetModuleClock
;;;326    
;;;327        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;328        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000066  6be0              LDR      r0,[r4,#0x3c]
000068  f420007f          BIC      r0,r0,#0xff0000
00006c  63e0              STR      r0,[r4,#0x3c]
;;;329        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00006e  6be0              LDR      r0,[r4,#0x3c]
000070  f44000cc          ORR      r0,r0,#0x660000
000074  63e0              STR      r0,[r4,#0x3c]
;;;330    
;;;331        CLK_EnableModuleClock(TMR1_MODULE);
000076  4d0a              LDR      r5,|L4.160|
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       CLK_EnableModuleClock
;;;332        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00007e  2200              MOVS     r2,#0
000080  f44f41e0          MOV      r1,#0x7000
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       CLK_SetModuleClock
;;;333    	
;;;334        /* Update System Core Clock */
;;;335        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;336        SystemCoreClockUpdate();
00008a  f7fffffe          BL       SystemCoreClockUpdate
00008e  2000              MOVS     r0,#0
000090  f8c40100          STR      r0,[r4,#0x100]
;;;337    
;;;338        /* Lock protected registers */
;;;339        SYS_LockReg();
;;;340    }
000094  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP

000096  0000              DCW      0x0000
                  |L4.152|
                          DCD      0x0b71b000
                  |L4.156|
                          DCD      0x57803d10
                  |L4.160|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;201    
;;;202    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L5.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;205        TIMER_EnableInt(TIMER1);
;;;206        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;207        TIMER_Start(TIMER1);
;;;208    }
000028  bd10              POP      {r4,pc}
;;;209    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;174    
;;;175    void TMR1_IRQHandler(void)
000000  480f              LDR      r0,|L6.64|
;;;176    {
000002  b500              PUSH     {lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d016              BEQ      |L6.60|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;177    //	static uint32_t LOG = 0;
;;;178    
;;;179    	
;;;180        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;181        {
;;;182            TIMER_ClearIntFlag(TIMER1);
;;;183    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4a0b              LDR      r2,|L6.68|
000018  6850              LDR      r0,[r2,#4]  ; counter_tick
;;;184    
;;;185    		if ((get_tick() % 1000) == 0)
00001a  f44f717a          MOV      r1,#0x3e8
00001e  fbb0f3f1          UDIV     r3,r0,r1
000022  fb010013          MLS      r0,r1,r3,r0
000026  b940              CBNZ     r0,|L6.58|
;;;186    		{
;;;187    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;188    			PH0 ^= 1;
000028  4807              LDR      r0,|L6.72|
00002a  6801              LDR      r1,[r0,#0]
00002c  f0810101          EOR      r1,r1,#1
000030  6001              STR      r1,[r0,#0]
;;;189    
;;;190    
;;;191    			set_flag(flag_read_wrte_test , ENABLE);	
000032  6810              LDR      r0,[r2,#0]  ; BitFlag
000034  f0400002          ORR      r0,r0,#2
000038  6010              STR      r0,[r2,#0]  ; BitFlag
                  |L6.58|
00003a  6850              LDR      r0,[r2,#4]  ; counter_tick
                  |L6.60|
;;;192    		}
;;;193    
;;;194    		if ((get_tick() % 50) == 0)
;;;195    		{
;;;196    
;;;197    		}	
;;;198        }
;;;199    }
00003c  bd00              POP      {pc}
;;;200    
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      0x40050100
                  |L6.68|
                          DCD      ||.data||
                  |L6.72|
                          DCD      0x400049c0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;241    
;;;242    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L7.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L7.18|
00000c  e004              B        |L7.24|
                  |L7.14|
;;;245        {
;;;246            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;247            {
;;;248    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L7.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;246
000014  0449              LSLS     r1,r1,#17             ;246
000016  d5fa              BPL      |L7.14|
                  |L7.24|
;;;249            }
;;;250        }
;;;251    
;;;252        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L7.46|
;;;253        {
;;;254            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L7.46|
;;;255        }	
;;;256    }
00002e  bd10              POP      {r4,pc}
;;;257    
                          ENDP

                  |L7.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;257    
;;;258    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;259    {
;;;260        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L8.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;261    
;;;262        /* Configure UART0 and set UART0 baud rate */
;;;263        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L8.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;264    
;;;265    	/* Set UART receive time-out */
;;;266    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;267    
;;;268    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;269    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;270    
;;;271    	/* Enable UART Interrupt - */
;;;272    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;273    	
;;;274    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;275    
;;;276    	#if (_debug_log_UART_ == 1)	//debug
;;;277    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a010              ADR      r0,|L8.132|
000044  f7fffffe          BL       __2printf
;;;278    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L8.160|
000050  f7fffffe          BL       __2printf
;;;279    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a017              ADR      r0,|L8.184|
00005c  f7fffffe          BL       __2printf
;;;280    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01a              ADR      r0,|L8.208|
000068  f7fffffe          BL       __2printf
;;;281    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a01d              ADR      r0,|L8.236|
000078  f7ffbffe          B.W      __2printf
;;;282    	#endif
;;;283    }
;;;284    
                          ENDP

                  |L8.124|
                          DCD      0x04000010
                  |L8.128|
                          DCD      0x40070000
                  |L8.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L8.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L8.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L8.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L8.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;209    
;;;210    void UARTx_Process(void)
000000  480e              LDR      r0,|L9.60|
;;;211    {
000002  b510              PUSH     {r4,lr}
;;;212    	uint8_t res = 0;
;;;213    	res = UART_READ(UART0);
000004  6800              LDR      r0,[r0,#0]
000006  b2c0              UXTB     r0,r0
;;;214    
;;;215    	if (res == 'x' || res == 'X')
000008  2878              CMP      r0,#0x78
00000a  d014              BEQ      |L9.54|
00000c  2858              CMP      r0,#0x58
00000e  d012              BEQ      |L9.54|
;;;216    	{
;;;217    		NVIC_SystemReset();
;;;218    	}
;;;219    
;;;220    	if (res > 0x7F)
000010  287f              CMP      r0,#0x7f
000012  d904              BLS      |L9.30|
;;;221    	{
;;;222    		printf("invalid command\r\n");
000014  e8bd4010          POP      {r4,lr}
000018  a009              ADR      r0,|L9.64|
00001a  f7ffbffe          B.W      __2printf
                  |L9.30|
;;;223    	}
;;;224    	else
;;;225    	{
;;;226    		switch(res)
00001e  285a              CMP      r0,#0x5a
000020  d009              BEQ      |L9.54|
000022  dc04              BGT      |L9.46|
000024  2831              CMP      r0,#0x31
000026  d008              BEQ      |L9.58|
000028  2858              CMP      r0,#0x58
00002a  d106              BNE      |L9.58|
00002c  e003              B        |L9.54|
                  |L9.46|
00002e  2878              CMP      r0,#0x78
000030  d001              BEQ      |L9.54|
000032  287a              CMP      r0,#0x7a
000034  d101              BNE      |L9.58|
                  |L9.54|
;;;227    		{
;;;228    			case '1':
;;;229    				break;
;;;230    
;;;231    			case 'X':
;;;232    			case 'x':
;;;233    			case 'Z':
;;;234    			case 'z':
;;;235    				NVIC_SystemReset();		
000036  f7fffffe          BL       NVIC_SystemReset
                  |L9.58|
;;;236    				break;
;;;237    		}
;;;238    	}
;;;239    }
00003a  bd10              POP      {r4,pc}
;;;240    
                          ENDP

                  |L9.60|
                          DCD      0x40070000
                  |L9.64|
000040  696e7661          DCB      "invalid command\r\n",0
000044  6c696420
000048  636f6d6d
00004c  616e640d
000050  0a00    
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;34     
;;;35     void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;36     {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4680              MOV      r8,r0
;;;37         uint16_t i = 0;	
00000a  2400              MOVS     r4,#0
;;;38     	
;;;39         for (i = 0; i < nBytes; i++)
;;;40         {
;;;41             if (src[i] != des[i])
;;;42             {
;;;43                 printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
;;;44     			set_flag(flag_error , ENABLE);
00000c  4d0f              LDR      r5,|L10.76|
00000e  e00e              B        |L10.46|
                  |L10.16|
000010  f8182004          LDRB     r2,[r8,r4]            ;41
000014  5d3b              LDRB     r3,[r7,r4]            ;41
000016  429a              CMP      r2,r3                 ;41
000018  d007              BEQ      |L10.42|
00001a  4621              MOV      r1,r4                 ;43
00001c  a00c              ADR      r0,|L10.80|
00001e  f7fffffe          BL       __2printf
000022  6828              LDR      r0,[r5,#0]  ; BitFlag
000024  f0400004          ORR      r0,r0,#4
000028  6028              STR      r0,[r5,#0]  ; BitFlag
                  |L10.42|
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4                 ;39
                  |L10.46|
00002e  42b4              CMP      r4,r6                 ;39
000030  dbee              BLT      |L10.16|
;;;45             }
;;;46         }
;;;47     
;;;48     	if (!is_flag_set(flag_error))
000032  6828              LDR      r0,[r5,#0]  ; BitFlag
000034  0740              LSLS     r0,r0,#29
000036  d407              BMI      |L10.72|
;;;49     	{
;;;50         	printf("%s finish \r\n" , __FUNCTION__);	
000038  490e              LDR      r1,|L10.116|
00003a  a00f              ADR      r0,|L10.120|
00003c  f7fffffe          BL       __2printf
;;;51     		set_flag(flag_error , DISABLE);
000040  6828              LDR      r0,[r5,#0]  ; BitFlag
000042  f0200004          BIC      r0,r0,#4
000046  6028              STR      r0,[r5,#0]  ; BitFlag
                  |L10.72|
;;;52     	}
;;;53     
;;;54     }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;55     
                          ENDP

                  |L10.76|
                          DCD      ||.data||
                  |L10.80|
000050  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
000054  72206964
000058  78203a20
00005c  25346420
000060  3a203078
000064  25325820
000068  2c203078
00006c  2532580d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L10.116|
                          DCD      ||.constdata||
                  |L10.120|
000078  25732066          DCB      "%s finish \r\n",0
00007c  696e6973
000080  68200d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.copy_buffer||, CODE, READONLY, ALIGN=1

                  copy_buffer PROC
;;;71     
;;;72     void copy_buffer(void *dest, void *src, unsigned int size)
000000  b510              PUSH     {r4,lr}
;;;73     {
;;;74         uint8_t *pu8Src, *pu8Dest;
;;;75         unsigned int i;
;;;76         
;;;77         pu8Dest = (uint8_t *)dest;
;;;78         pu8Src  = (uint8_t *)src;
;;;79     
;;;80     
;;;81     	#if 0
;;;82     	  while (size--)
;;;83     	    *pu8Dest++ = *pu8Src++;
;;;84     	#else
;;;85         for (i = 0; i < size; i++)
000002  2300              MOVS     r3,#0
000004  e002              B        |L11.12|
                  |L11.6|
;;;86             pu8Dest[i] = pu8Src[i];
000006  5ccc              LDRB     r4,[r1,r3]
000008  54c4              STRB     r4,[r0,r3]
00000a  1c5b              ADDS     r3,r3,#1
                  |L11.12|
00000c  4293              CMP      r3,r2                 ;85
00000e  d3fa              BCC      |L11.6|
;;;87     	#endif
;;;88     }
000010  bd10              POP      {r4,pc}
;;;89     
                          ENDP


                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;89     
;;;90     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;91     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;92         uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;93         
;;;94         printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L12.56|
00000a  f7fffffe          BL       __2printf
;;;95         for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L12.42|
                  |L12.16|
;;;96         {
;;;97             printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L12.76|
000014  f7fffffe          BL       __2printf
;;;98             if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L12.38|
;;;99             {
;;;100                printf("\r\n");
000020  a00c              ADR      r0,|L12.84|
000022  f7fffffe          BL       __2printf
                  |L12.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;95
                  |L12.42|
00002a  42ac              CMP      r4,r5                 ;95
00002c  dbf0              BLT      |L12.16|
;;;101            }            
;;;102        }
;;;103        printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L12.88|
000034  f7ffbffe          B.W      __2printf
;;;104    }
;;;105    
                          ENDP

                  |L12.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L12.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L12.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L12.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;105    
;;;106    void  dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;107    {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;108        int     nIdx, i;
;;;109    
;;;110        nIdx = 0;
000008  2500              MOVS     r5,#0
00000a  e025              B        |L13.88|
                  |L13.12|
;;;111        while (nBytes > 0)
;;;112        {
;;;113            printf("0x%04X  ", nIdx);
00000c  4629              MOV      r1,r5
00000e  a016              ADR      r0,|L13.104|
000010  f7fffffe          BL       __2printf
;;;114            for (i = 0; i < 16; i++)
000014  2400              MOVS     r4,#0
                  |L13.22|
;;;115                printf("%02X ", pucBuff[nIdx + i]);
000016  1928              ADDS     r0,r5,r4
000018  5c39              LDRB     r1,[r7,r0]
00001a  a016              ADR      r0,|L13.116|
00001c  f7fffffe          BL       __2printf
000020  1c64              ADDS     r4,r4,#1
000022  2c10              CMP      r4,#0x10              ;114
000024  dbf7              BLT      |L13.22|
;;;116            printf("  ");
000026  a015              ADR      r0,|L13.124|
000028  f7fffffe          BL       __2printf
;;;117            for (i = 0; i < 16; i++)
00002c  2400              MOVS     r4,#0
                  |L13.46|
;;;118            {
;;;119                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002e  1928              ADDS     r0,r5,r4
000030  5c39              LDRB     r1,[r7,r0]
000032  f1a10020          SUB      r0,r1,#0x20
000036  285f              CMP      r0,#0x5f
000038  d203              BCS      |L13.66|
;;;120                    printf("%c", pucBuff[nIdx + i]);
00003a  a011              ADR      r0,|L13.128|
00003c  f7fffffe          BL       __2printf
000040  e002              B        |L13.72|
                  |L13.66|
;;;121                else
;;;122                    printf(".");
000042  a010              ADR      r0,|L13.132|
000044  f7fffffe          BL       __2printf
                  |L13.72|
000048  1c64              ADDS     r4,r4,#1
00004a  1e76              SUBS     r6,r6,#1
00004c  2c10              CMP      r4,#0x10              ;117
00004e  dbee              BLT      |L13.46|
;;;123                nBytes--;
;;;124            }
;;;125            nIdx += 16;
;;;126            printf("\n");
000050  a00d              ADR      r0,|L13.136|
000052  3510              ADDS     r5,r5,#0x10
000054  f7fffffe          BL       __2printf
                  |L13.88|
000058  2e00              CMP      r6,#0                 ;111
00005a  dcd7              BGT      |L13.12|
;;;127        }
;;;128        printf("\n");
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  a009              ADR      r0,|L13.136|
000062  f7ffbffe          B.W      __2printf
;;;129    }
;;;130    
                          ENDP

000066  0000              DCW      0x0000
                  |L13.104|
000068  30782530          DCB      "0x%04X  ",0
00006c  34582020
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L13.116|
000074  25303258          DCB      "%02X ",0
000078  2000    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L13.124|
00007c  202000            DCB      "  ",0
00007f  00                DCB      0
                  |L13.128|
000080  256300            DCB      "%c",0
000083  00                DCB      0
                  |L13.132|
000084  2e00              DCB      ".",0
000086  00                DCB      0
000087  00                DCB      0
                  |L13.136|
000088  0a00              DCB      "\n",0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;24     
;;;25     uint32_t get_tick(void)
000000  4801              LDR      r0,|L14.8|
;;;26     {
;;;27     	return (counter_tick);
000002  6840              LDR      r0,[r0,#4]  ; counter_tick
;;;28     }
000004  4770              BX       lr
;;;29     
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.loop_test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  loop_test PROC
;;;130    
;;;131    void loop_test(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;132    {
;;;133    	uint32_t idx = 0;
;;;134    	uint32_t i = 0;
;;;135    	
;;;136    	if (is_flag_set(flag_read_wrte_test))
000004  4836              LDR      r0,|L15.224|
000006  2400              MOVS     r4,#0                 ;134
000008  6801              LDR      r1,[r0,#0]  ; BitFlag
00000a  0789              LSLS     r1,r1,#30
00000c  d565              BPL      |L15.218|
;;;137    	{
;;;138    		set_flag(flag_read_wrte_test , DISABLE);
00000e  6801              LDR      r1,[r0,#0]  ; BitFlag
000010  f0210102          BIC      r1,r1,#2
000014  6001              STR      r1,[r0,#0]  ; BitFlag
;;;139    
;;;140    		idx = 0xF0;
000016  26f0              MOVS     r6,#0xf0
;;;141    		DataFlashRead(idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
000018  f1000208          ADD      r2,r0,#8
00001c  2108              MOVS     r1,#8
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       DataFlashRead
;;;142    		printf("0x%2X : 0x%4X \r\n" , idx , Storage_Block[0] );
000024  4d2e              LDR      r5,|L15.224|
000026  4631              MOV      r1,r6
000028  3508              ADDS     r5,r5,#8
00002a  a02e              ADR      r0,|L15.228|
00002c  682a              LDR      r2,[r5,#0]  ; Storage_Block
00002e  f7fffffe          BL       __2printf
;;;143    		Storage_Block[0] += 2;
000032  6828              LDR      r0,[r5,#0]  ; Storage_Block
;;;144    		DataFlashWrite(idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);		
000034  462a              MOV      r2,r5
000036  1c80              ADDS     r0,r0,#2              ;143
000038  6028              STR      r0,[r5,#0]  ; Storage_Block
00003a  2108              MOVS     r1,#8
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       DataFlashWrite
;;;145    
;;;146    		idx = 0x10;
000042  2610              MOVS     r6,#0x10
;;;147    		DataFlashRead(idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
000044  462a              MOV      r2,r5
000046  2108              MOVS     r1,#8
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       DataFlashRead
;;;148    		printf("0x%2X : 0x%4X \r\n" , idx , Storage_Block[0] );
00004e  4631              MOV      r1,r6
000050  a024              ADR      r0,|L15.228|
000052  682a              LDR      r2,[r5,#0]  ; Storage_Block
000054  f7fffffe          BL       __2printf
;;;149    		Storage_Block[0] += 1;
000058  6828              LDR      r0,[r5,#0]  ; Storage_Block
;;;150    		DataFlashWrite(idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);		
00005a  462a              MOV      r2,r5
00005c  1c40              ADDS     r0,r0,#1              ;149
00005e  6028              STR      r0,[r5,#0]  ; Storage_Block
000060  2108              MOVS     r1,#8
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       DataFlashWrite
;;;151    		
;;;152    		idx = 0x20;
000068  2620              MOVS     r6,#0x20
;;;153    		DataFlashRead(idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
00006a  462a              MOV      r2,r5
00006c  2108              MOVS     r1,#8
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       DataFlashRead
;;;154    		printf("0x%2X : 0x%4X \r\n" , idx , Storage_Block[0] );
000074  4631              MOV      r1,r6
000076  a01b              ADR      r0,|L15.228|
000078  682a              LDR      r2,[r5,#0]  ; Storage_Block
00007a  f7fffffe          BL       __2printf
;;;155    		Storage_Block[0] += 1;
00007e  6828              LDR      r0,[r5,#0]  ; Storage_Block
;;;156    		DataFlashWrite(idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);	
000080  462a              MOV      r2,r5
000082  1c40              ADDS     r0,r0,#1              ;155
000084  6028              STR      r0,[r5,#0]  ; Storage_Block
000086  2108              MOVS     r1,#8
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       DataFlashWrite
;;;157    
;;;158    		// need to align uint8_t to uint32_t  
;;;159    		for (i = 0 ; i < 16 ; i++)
;;;160    		{
;;;161    			idx = 0x30 + i*4;
00008e  2730              MOVS     r7,#0x30
                  |L15.144|
;;;162    			DataFlashRead(idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0] );
000090  4a13              LDR      r2,|L15.224|
000092  eb070684          ADD      r6,r7,r4,LSL #2       ;161
000096  3208              ADDS     r2,r2,#8
000098  2108              MOVS     r1,#8
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       DataFlashRead
;;;163    			printf("0x%2X : 0x%4X  , " , idx , Storage_Block[0]);
0000a0  4631              MOV      r1,r6
0000a2  a015              ADR      r0,|L15.248|
0000a4  682a              LDR      r2,[r5,#0]  ; Storage_Block
0000a6  f7fffffe          BL       __2printf
;;;164    			Storage_Block[0] += 1;
0000aa  6828              LDR      r0,[r5,#0]  ; Storage_Block
;;;165    			DataFlashWrite(idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0] );
0000ac  4a0c              LDR      r2,|L15.224|
0000ae  1c40              ADDS     r0,r0,#1              ;164
0000b0  6028              STR      r0,[r5,#0]  ; Storage_Block
0000b2  3208              ADDS     r2,r2,#8
0000b4  2108              MOVS     r1,#8
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       DataFlashWrite
;;;166    	        if ((i+1)%4 ==0)
0000bc  07a0              LSLS     r0,r4,#30
0000be  f1b04f40          CMP      r0,#0xc0000000
0000c2  d102              BNE      |L15.202|
;;;167    	        {
;;;168    	            printf("\r\n");
0000c4  a011              ADR      r0,|L15.268|
0000c6  f7fffffe          BL       __2printf
                  |L15.202|
0000ca  1c64              ADDS     r4,r4,#1
0000cc  2c10              CMP      r4,#0x10              ;159
0000ce  d3df              BCC      |L15.144|
;;;169    	        }  			
;;;170    		}
;;;171    		printf("\r\n");
0000d0  e8bd41f0          POP      {r4-r8,lr}
0000d4  a00d              ADR      r0,|L15.268|
0000d6  f7ffbffe          B.W      __2printf
                  |L15.218|
;;;172    	}
;;;173    }
0000da  e8bd81f0          POP      {r4-r8,pc}
;;;174    
                          ENDP

0000de  0000              DCW      0x0000
                  |L15.224|
                          DCD      ||.data||
                  |L15.228|
0000e4  30782532          DCB      "0x%2X : 0x%4X \r\n",0
0000e8  58203a20
0000ec  30782534
0000f0  58200d0a
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L15.248|
0000f8  30782532          DCB      "0x%2X : 0x%4X  , ",0
0000fc  58203a20
000100  30782534
000104  5820202c
000108  2000    
00010a  00                DCB      0
00010b  00                DCB      0
                  |L15.268|
00010c  0d0a00            DCB      "\r\n",0
00010f  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;349    
;;;350    int main()
000000  2400              MOVS     r4,#0
;;;351    {
;;;352    	uint32_t i = 0;
;;;353    	
;;;354        SYS_Init();
000002  f7fffffe          BL       SYS_Init
;;;355    
;;;356    	UART0_Init();
000006  f7fffffe          BL       UART0_Init
;;;357    	Custom_Init();	
00000a  f7fffffe          BL       Custom_Init
;;;358    	TIMER1_Init();
00000e  f7fffffe          BL       TIMER1_Init
;;;359    
;;;360    	DataFlashInit();
000012  f7fffffe          BL       DataFlashInit
;;;361    
;;;362    	Storage_Block[0] = 0x0A;	
000016  4d13              LDR      r5,|L16.100|
000018  200a              MOVS     r0,#0xa
;;;363    	DataFlashWrite(0xF0 , BUFFER_PAGE_SIZE , (uint32_t)&Storage_Block[0] );
00001a  462a              MOV      r2,r5
00001c  6028              STR      r0,[r5,#0]  ; Storage_Block
00001e  2108              MOVS     r1,#8
000020  20f0              MOVS     r0,#0xf0
000022  f7fffffe          BL       DataFlashWrite
;;;364    
;;;365    	Storage_Block[0] = 0x1A;	
000026  201a              MOVS     r0,#0x1a
;;;366    	DataFlashWrite(0x10 , BUFFER_PAGE_SIZE , (uint32_t)&Storage_Block[0] );
000028  6028              STR      r0,[r5,#0]  ; Storage_Block
00002a  462a              MOV      r2,r5
00002c  2108              MOVS     r1,#8
00002e  2010              MOVS     r0,#0x10
000030  f7fffffe          BL       DataFlashWrite
;;;367    	
;;;368    	Storage_Block[0] = 0x2A;
000034  202a              MOVS     r0,#0x2a
;;;369    	DataFlashWrite(0x20 , BUFFER_PAGE_SIZE , (uint32_t)&Storage_Block[0] );
000036  6028              STR      r0,[r5,#0]  ; Storage_Block
000038  462a              MOV      r2,r5
00003a  2108              MOVS     r1,#8
00003c  2020              MOVS     r0,#0x20
00003e  f7fffffe          BL       DataFlashWrite
;;;370    
;;;371    	for ( i = 0 ; i < 16 ; i++)
;;;372    	{
;;;373    		Storage_Block[0] = 0x3A + i;
;;;374    		DataFlashWrite(0x30 + i*4 , BUFFER_PAGE_SIZE , (uint32_t)&Storage_Block[0] );
000042  2630              MOVS     r6,#0x30
                  |L16.68|
000044  f104003a          ADD      r0,r4,#0x3a           ;373
000048  6028              STR      r0,[r5,#0]  ; Storage_Block
00004a  eb060084          ADD      r0,r6,r4,LSL #2
00004e  4a05              LDR      r2,|L16.100|
000050  2108              MOVS     r1,#8
000052  f7fffffe          BL       DataFlashWrite
000056  1c64              ADDS     r4,r4,#1
000058  2c10              CMP      r4,#0x10              ;371
00005a  d3f3              BCC      |L16.68|
                  |L16.92|
;;;375    	}
;;;376    				
;;;377        /* Got no where to go, just loop forever */
;;;378        while(1)
;;;379        {
;;;380    		loop_test();
00005c  f7fffffe          BL       loop_test
000060  e7fc              B        |L16.92|
;;;381    
;;;382        }
;;;383    }
;;;384    
                          ENDP

000062  0000              DCW      0x0000
                  |L16.100|
                          DCD      ||.data||+0x8

                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;55     
;;;56     void reset_buffer(void *dest, unsigned int val, unsigned int size)
000000  b2c9              UXTB     r1,r1
;;;57     {
000002  e001              B        |L17.8|
                  |L17.4|
;;;58         uint8_t *pu8Dest;
;;;59     //    unsigned int i;
;;;60         
;;;61         pu8Dest = (uint8_t *)dest;
;;;62     
;;;63     	#if 1
;;;64     	while (size-- > 0)
;;;65     		*pu8Dest++ = val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L17.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L17.4|
;;;66     	#else
;;;67     	memset(pu8Dest, val, size * (sizeof(pu8Dest[0]) ));
;;;68     	#endif
;;;69     	
;;;70     }
00000c  4770              BX       lr
;;;71     
                          ENDP


                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;29     
;;;30     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L18.8|
;;;31     {
;;;32     	counter_tick = t;
000002  6048              STR      r0,[r1,#4]  ; counter_tick
;;;33     }
000004  4770              BX       lr
;;;34     
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;19     
;;;20     void tick_counter(void)
000000  4802              LDR      r0,|L19.12|
;;;21     {
;;;22     	counter_tick++;
000002  6841              LDR      r1,[r0,#4]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; counter_tick
;;;23     }
000008  4770              BX       lr
;;;24     
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000004  6172655f          DCB      0x61,0x72,0x65,0x5f
000008  62756666          DCB      0x62,0x75,0x66,0x66
00000c  657200            DCB      0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  Storage_Block
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
